package JolleeB.BachelorT.Algorithmen;

import JolleeB.BachelorT.Utils.Conversion;

public class GaussianAnalyzer {

	private int imgWidth;
	private int imgHeight;
	private int imgLength;
	private float learningRate = 0.01f;
	private float minimumProbability = 0.01f;
	private float[] mean;
	private float[] variance;
	
	public GaussianAnalyzer(byte[] firstImg, int imgWidth, int imgHeight){
		this.imgWidth = imgWidth;
		this.imgHeight = imgHeight;
		this.imgLength = firstImg.length;
		if(imgLength != imgWidth*imgHeight)throw new IllegalArgumentException();
		this.mean = new float[imgLength];
		this.variance = new float[imgLength];
		for(int i =0; i <imgLength; i++){
			this.mean[i] = Conversion.byteToFloat(firstImg[i]);
			this.variance[i] = 3;
		}
	}
	
	public byte[] convertImage(byte[] imgIn){
		if(imgIn.length != imgLength) throw new IllegalArgumentException();
		byte[] imgOut = new byte[imgLength];
		for(int i = 0; i <imgLength; i++){
			int x = Conversion.byteToInt(imgIn[i]);
//			//Calculate probability of belonging to this Gaussian distribution
//			//	Calculate exponent
//			float probability = newVariance*newVariance;
//			probability /= -2*(variance[i]*variance[i]);
//			//	Calculate rest
//			probability = (float)Math.pow(Math.E, probability);
//			probability /= variance[i]*Math.sqrt(2*Math.PI);
//			boolean isForeground = probability < minimumProbability;
			
			boolean isForeground = Math.abs(x-mean[i])>variance[i];
			
			//Update mean and variance values
			mean[i] = mean[i] * (1-learningRate) + (learningRate * x);
			variance[i] = (float)Math.sqrt(variance[i] * (1-learningRate) + (learningRate *(x-mean[i])*(x-mean[i])));
//			variance[i] *= variance[i];
			
			//Update Pixel in new Picture
			if(isForeground) imgOut[i] = (byte)mean[i];	
			else imgOut[i] = imgIn[i];
		}
		return imgOut;
	}
	
}