package JolleeB.BachelorT.Algorithmen;

import JolleeB.BachelorT.Utils.Conversion;

public class MRFOptimizer {

	public float[] optimizeRandomField(byte[] img, float[] field, int width, int height,int runs){
		if(field.length != width*height) throw new IllegalArgumentException();
		int changeCounter =1;
		float[] fieldOut = field.clone();
		for(int i =0; i < runs; i++){
			changeCounter =0;
			float[] newField = new float[field.length];
			for(int y =0; y < height; y++){
				for(int x =0; x < width; x++){
					int pos = y*width+x;
					
					float distanceSum =0;
					float probabilitiesFactorDistance =0;
					for(int lFactor =-3; lFactor<=3; lFactor+=3){
						for(int kFactor =-3; kFactor<=3;kFactor+=3){
							int l = lFactor*3;
							int k = kFactor*3;
							int newY = y+l;
							int newX = x+k;
							if(newY <0 || newY >=height)newY-=l;
							if(newX <0 || newX >=width )newX-=k;
							int newPos = newY*width+newX;
							if(newPos != pos){
								int diff = (Conversion.byteToInt(img[pos])-Conversion.byteToInt(img[newPos]));
								diff *= diff;
								if(diff <=0) diff =1;
								distanceSum += 1f/diff;
								probabilitiesFactorDistance += field[newPos]*(1f/diff);
							}
						}
					}
					newField[pos] = probabilitiesFactorDistance/distanceSum;
				}
			}
		}
		return newF;
	}
}
