package JolleeB.BachelorT.Algorithmen;

import java.util.Random;

import JolleeB.BachelorT.Utils.Conversion;

public class GMMAnalyzerHSV {

	private int imgLength;
	private float learningRate = 0.03f;
	private float[] mean;
	private float[] variance;
	
	public GMMAnalyzerHSV(int imgLength){
		this.imgLength = imgLength;
		this.mean = new float[imgLength];
		this.variance = new float[imgLength];
		Random r = new Random();
		for(int i =0; i <imgLength; i++){
			this.mean[i] = -1;
			this.variance[i] = 3;
		}
	}
	
	public byte[] convertImage(byte[] imgIn){
		if(imgIn.length != imgLength) throw new IllegalArgumentException();
		byte[] imgOut = new byte[imgLength];
		if(mean[0]==-1){
			for(int i =0; i<this.imgLength; i++){
				mean[i] = Conversion.byteToFloat(imgIn[i]);
			}
			imgOut = imgIn.clone();
			return imgOut;
		}
		for(int i = 0; i <imgLength; i+=3){
			int r = Conversion.byteToInt(imgIn[i]);
			int g = Conversion.byteToInt(imgIn[i+1]);
			int b = Conversion.byteToInt(imgIn[i+2]);
			int[] hsv = Conversion.rgbToHsv(r,g,b);
			int h = hsv[0];
			int s = hsv[1];
			int v = hsv[2];
			boolean isForeground = Math.abs(h-mean[i])>2.5*variance[i];
			isForeground = isForeground && Math.abs(s-mean[i+1])>2.5*variance[i+1];
			isForeground = isForeground && Math.abs(v-mean[i+2])>2.5*variance[i+2];
			
			isForeground =  ((Math.abs(h-mean[i])+Math.abs(s-mean[i+1])+Math.abs(v-mean[i+2])>0.5*variance[i]));
			
			//Update mean and variance values
			mean[i] = mean[i] * (1-learningRate) + (learningRate * h);
			variance[i] = (float)Math.sqrt(variance[i] * (1-learningRate) + (learningRate *
					Math.abs(h-mean[i])+Math.abs(s-mean[i+1])+Math.abs(v-mean[i+2])*
							(Math.abs(h-mean[i])+Math.abs(s-mean[i+1])+Math.abs(v-mean[i+2]))));
			mean[i+1] = mean[i+1] * (1-learningRate) + (learningRate * s);
			mean[i+2] = mean[i+2] * (1-learningRate) + (learningRate * s);
			
			//Update Pixel in new Picture
			if(isForeground){
				int[] rgb = Conversion.hsvToRgb((int)mean[i], (int)mean[i+1], (int)mean[i+2]);
				imgOut[i] = (byte)rgb[0];	
				imgOut[i+1] = (byte)rgb[1];	
				imgOut[i+2] = (byte)rgb[2];	
			}
			else {
				imgOut[i] = imgIn[i];
				imgOut[i+1] = imgIn[i+1];
				imgOut[i+2] = imgIn[i+2];
			}
		}
		return imgOut;
	}
	
}