package JolleeB.BachelorT.Algorithmen;

import JolleeB.BachelorT.Utils.Conversion;

public class NeighboursMOGAnalyzer {
	private int imgLength;
	private int imgHeight;
	private int imgWidth;
	private float learningRate = 0.003f;
	private float initialVariance = 30;
	private float initialWeight = 0.05f;
	//TODO THIS DOES NOT MAKE MUCH DIFFERENCE
	private float maxDistanceFactor = 2.5f;
	//TODO this is implemented wrong
	private float backgroundPercentage = 0.7f;
	private int amountGaussian;
	private float[][] mean;
	private float[][] variance;
	private float[][] weights;
	private float[][] meanNeighbour;
	private float[][] varianceNeighbour;
	private float[][] weightsNeighbour;
	private final float SQRT2PI = (float)Math.sqrt(2*Math.PI);
	
	public NeighboursMOGAnalyzer(int imgWidth,int imgHeight, int amountGaussians){
		this.imgLength = imgWidth*imgHeight;
		this.imgHeight = imgHeight;
		this.imgWidth = imgWidth;
		this.amountGaussian = amountGaussians;
		this.mean = new float[amountGaussians][imgLength];
		this.variance = new float[amountGaussians][imgLength];
		this.weights = new float[amountGaussians][imgLength];
		this.meanNeighbour = new float[amountGaussians][imgLength];
		this.varianceNeighbour = new float[amountGaussians][imgLength];
		this.weightsNeighbour = new float[amountGaussians][imgLength];
		for(int i =0; i <imgLength; i++){
			float varValue = initialVariance;
			for(int k = 0; k < amountGaussians; k++){
				this.variance[k][i] = varValue;
				this.weights[k][i] = initialWeight;
				this.varianceNeighbour[k][i] = varValue;
				this.weightsNeighbour[k][i] = initialWeight;
			}
		}
	}
	
	public byte[] convertImage(byte[] imgIn){
		if(imgIn.length != this.imgLength) throw new IllegalArgumentException();
		byte[] imgOut = new byte[this.imgLength];
		boolean[] foreground = new boolean[this.imgLength];
		boolean[] foregroundNeighbourhood = calculateNeighboorhoodMOGS(imgIn);
		boolean[] foregroundPixels = calculateMOGS(imgIn);
		for(int y =0;y< this.imgHeight; y++){
			for(int x =0; x < this.imgWidth; x++){
				int pos = y*this.imgWidth+x;
				
				if(foregroundNeighbourhood[pos])
				
				for(int l =-1; l<=1; l++){
					for(int k =-1; k<=1; k++){
						int newY = y+l;
						int newX = val+k;
						if(newY <0) newY =0;
						if(newX <0) newX =0;
						if(newY >=imgHeight) newY = imgHeight-1;
						if(newX >=imgWidth) newX = imgWidth-1;
						
					}
				}
			}
		}
		
		return imgOut;
	}
	
	private boolean[] calculateMOGS(byte[] imgIn){
		if(imgIn.length != this.imgLength) throw new IllegalArgumentException();
		byte[] imgOut = new byte[this.imgLength];
		boolean[] foreground = new boolean[this.imgLength];
		
		//Second Round, calculate mogs
		for(int y = 0; y <this.imgHeight; y++){
			for(int x1 =0; x1 < this.imgWidth; x1++){
				int pos = y*this.imgWidth+x1;
				float[] probability = new float[amountGaussian];
				int val=Conversion.byteToInt(imgIn[pos]);
				int matchedGaussian =-1;
				float hightestVariance = 1000;
				for(int k =0; k < this.amountGaussian; k++){
					float kVariance = (float)Math.pow(val-mean[k][pos],2);
					//Take first match to save time
					if(kVariance < maxDistanceFactor*variance[k][pos] && kVariance<hightestVariance){
						matchedGaussian = k;
						hightestVariance = kVariance;
						break;
					}
				}
				//normalize the weights
				normalizeWeights(pos);
				//Sort Gaussians by their ability to represent the background for later use
				float[][] sortedGaussians = sortGaussians(pos);
				//If no match was found
				if(matchedGaussian ==-1){
					int leastWeighted = leastWeighted(pos);
					mean[leastWeighted][pos] = val;
					variance[leastWeighted][pos] = initialVariance;
					foreground[pos] = false;
				}
				else{
					//Calculate probability of belonging to this Gaussian distribution
					//	Calculate exponent
					probability[matchedGaussian] = hightestVariance*hightestVariance;
					probability[matchedGaussian] /= -2*(variance[matchedGaussian][pos]*variance[matchedGaussian][pos]);
					//	Calculate rest
					probability[matchedGaussian] = (float)Math.pow(Math.E, probability[matchedGaussian]);
					probability[matchedGaussian] /= variance[matchedGaussian][pos]*SQRT2PI;
					
					for(int k = 0; k < amountGaussian; k++){
						weights[k][pos] = (1-learningRate)* weights[k][pos];
					}
					//Update mean and variance values
					weights[matchedGaussian][pos] += learningRate;
					probability[matchedGaussian]*= learningRate;
					mean[matchedGaussian][pos] = mean[matchedGaussian][pos] * (1-probability[matchedGaussian]) + (probability[matchedGaussian] * val);
					variance[matchedGaussian][pos] = (float)Math.sqrt(variance[matchedGaussian][pos] * (1-probability[matchedGaussian]) + (probability[matchedGaussian] *hightestVariance*hightestVariance));
					
					
					foreground[pos] = true;
				}
			}
		}
		return foreground;
	}
	
	private boolean[] calculateNeighboorhoodMOGS(byte[] imgIn){
		boolean[] foreground = new boolean[this.imgLength];
		
		//First Round, calculate for neighbourhood mog
		for(int y = 0; y <this.imgHeight; y++){
			for(int x1 =0; x1 < this.imgWidth; x1++){
				int pos = y*this.imgWidth+x1;
				float[] probability = new float[amountGaussian];
				int val = 0;
				for(int l =-1; l<=1; l++){
					for(int k =-1; k<=1; k++){
						int newY = y+l;
						int newX = val+k;
						if(newY <0) newY =0;
						if(newX <0) newX =0;
						if(newY >=imgHeight) newY = imgHeight-1;
						if(newX >=imgWidth) newX = imgWidth-1;
						val+=Conversion.byteToInt(imgIn[newY*this.imgWidth+newX]);
					}
				}
				val-=Conversion.byteToInt(imgIn[pos]);
				val/=8;
				int val = Conversion.byteToInt(imgIn[pos]);
				int matchedGaussian =-1;
				float hightestVariance = 1000;
				for(int k =0; k < this.amountGaussian; k++){
					float kVariance = (float)Math.pow(val-mean[k][pos],2);
					//Take first match to save time
					if(kVariance < maxDistanceFactor*variance[k][pos] && kVariance<hightestVariance){
						matchedGaussian = k;
						hightestVariance = kVariance;
						break;
					}
				}
				//normalize the weights
				normalizeWeights(pos);
				//Sort Gaussians by their ability to represent the background for later use
				float[][] sortedGaussians = sortGaussians(pos);
				//If no match was found
				if(matchedGaussian ==-1){
					int leastWeighted = leastWeighted(pos);
					mean[leastWeighted][pos] = val;
					variance[leastWeighted][pos] = initialVariance;
					foreground[pos] = true;
	//				imgOut[i] = 70;
				}
				else{
					//Calculate probability of belonging to this Gaussian distribution
					//	Calculate exponent
					probability[matchedGaussian] = hightestVariance*hightestVariance;
					probability[matchedGaussian] /= -2*(variance[matchedGaussian][pos]*variance[matchedGaussian][pos]);
					//	Calculate rest
					probability[matchedGaussian] = (float)Math.pow(Math.E, probability[matchedGaussian]);
					probability[matchedGaussian] /= variance[matchedGaussian][pos]*SQRT2PI;
					
					for(int k = 0; k < amountGaussian; k++){
						weights[k][pos] = (1-learningRate)* weights[k][pos];
					}
					//Update mean and variance values
					weights[matchedGaussian][pos] += learningRate;
					probability[matchedGaussian]*= learningRate;
					mean[matchedGaussian][pos] = mean[matchedGaussian][pos] * (1-probability[matchedGaussian]) + (probability[matchedGaussian] * val);
					variance[matchedGaussian][pos] = (float)Math.sqrt(variance[matchedGaussian][pos] * (1-probability[matchedGaussian]) + (probability[matchedGaussian] *hightestVariance*hightestVariance));
					
					//See if matched gaussian belongs to back or foreground
					boolean isBackground =false;
					float addedWeights =0;
					for(int k =0; k < amountGaussian; k++){
						int index = (int)sortedGaussians[0][k];
						addedWeights+=sortedGaussians[1][k];
						if(addedWeights>backgroundPercentage) break;
						if(matchedGaussian == index){
							isBackground = true;
							break;
						}
					}
					
					foreground[pos] = !isBackground;
	//				else imgOut[i] = -1;
				}
			}
		}
		return foreground;
	}
	
	/**
	 * returns a 2D Array with the indexes on first Array and weights on 2nd
	 * @param i
	 * @return
	 */
	private float[][] sortGaussians(int i){
		//Insertion sort is used
		float[][] result = new float[2][amountGaussian];
		float[] weights = new float[amountGaussian];
		for(int k = 0; k < amountGaussian; k++){
			weights[k] = this.weights[k][i]/variance[k][i];
		}
		for(int k =0; k < amountGaussian; k++){
			result[1][k] = -1;
		}
		for(int l = 0; l< amountGaussian; l++){
			float maxWeight = 0;
			int maxIndex =0 ;
			for(int k = 0; k < amountGaussian; k++){
				if(weights[k] > maxWeight) {
					maxWeight = weights[k];
					maxIndex = k;
				}
			}
			result[1][l] = this.weights[maxIndex][i];
			result[0][l] = maxIndex;
			weights[maxIndex] =0;
		}
		return result;
	}
	
	private void normalizeWeights(int i){
		float weightsAdded =0;
		for(int k=0; k < amountGaussian; k++){
			weightsAdded+=this.weights[k][i];
		}
		for(int k =0; k<amountGaussian; k++){
			this.weights[k][i] /= weightsAdded;
		}
	}
	
	private int leastWeighted(int i){
		int leastWeighted =0;
		for(int k = 0; k < amountGaussian; k++){
			if(weights[leastWeighted][i]> weights[k][i])
				leastWeighted = k;
		}
		return leastWeighted;
	}
	
}