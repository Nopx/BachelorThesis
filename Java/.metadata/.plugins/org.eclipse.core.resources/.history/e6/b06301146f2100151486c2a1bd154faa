package JolleeB.BachelorT.Algorithmen;

import JolleeB.BachelorT.Utils.Conversion;

public class NeighboursMOGAnalyzer {
	private int imgLength;
	private int imgHeight;
	private int imgWidth;
	private float learningRate = 0.003f;
	private float initialVariance = 30;
	private float initialWeight = 0.05f;
	//TODO THIS DOES NOT MAKE MUCH DIFFERENCE
	private float maxDistanceFactor = 2.5f;
	//TODO this is implemented wrong
	private float backgroundPercentage = 0.7f;
	private int amountGaussian;
	private float[][] mean;
	private float[][] variance;
	private float[][] weights;
	private float[][] meanNeighbour;
	private float[][] varianceNeighbour;
	private float[][] weightsNeighbour;
	private final float SQRT2PI = (float)Math.sqrt(2*Math.PI);
	
	public NeighboursMOGAnalyzer(int imgWidth,int imgHeight, int amountGaussians){
		this.imgLength = imgWidth*imgHeight;
		this.imgHeight = imgHeight;
		this.imgWidth = imgWidth;
		this.amountGaussian = amountGaussians;
		this.mean = new float[amountGaussians][imgLength];
		this.variance = new float[amountGaussians][imgLength];
		this.weights = new float[amountGaussians][imgLength];
		this.meanNeighbour = new float[amountGaussians][imgLength];
		this.varianceNeighbour = new float[amountGaussians][imgLength];
		this.weightsNeighbour = new float[amountGaussians][imgLength];
		for(int i =0; i <imgLength; i++){
			float varValue = initialVariance;
			for(int k = 0; k < amountGaussians; k++){
				this.variance[k][i] = varValue;
				this.weights[k][i] = initialWeight;
				this.varianceNeighbour[k][i] = varValue;
				this.weightsNeighbour[k][i] = initialWeight;
			}
		}
	}
	
	public byte[] convertImage(byte[] imgIn){
		if(imgIn.length != this.imgLength) throw new IllegalArgumentException();
		byte[] imgOut = new byte[this.imgLength];
		boolean[] foreground = new boolean[this.imgLength];
		for(int y = 0; y <this.imgHeight; y++){
			for(int x1 =0; x1 < this.imgWidth; x1++){
				int i = y*this.imgWidth+x1;
				float[] probability = new float[amountGaussian];
				int val = 0;
				for(int l =-1; l<=1; l++){
					for(int k =-1; k<=1; k++){
						int newY = y+l;
						int newX = val+k;
						if(newY <0) newY =0;
						if(newX <0) newX =0;
						if(newY >=imgHeight) newY = imgHeight-1;
						if(newX >=imgWidth) newX = imgWidth-1;
						val+=Conversion.byteToInt(imgIn[newY*this.imgWidth+newX]);
					}
				}
				val-=Conversion.byteToInt(imgIn[i]);
				val/=8;
				int matchedGaussian =-1;
				float hightestVariance = 1000;
				for(int k =0; k < this.amountGaussian; k++){
					float kVariance = (float)Math.pow(val-mean[k][i],2);
					//Take first match to save time
					if(kVariance < maxDistanceFactor*variance[k][i] && kVariance<hightestVariance){
						matchedGaussian = k;
						hightestVariance = kVariance;
						break;
					}
				}
				//normalize the weights
				normalizeWeights(i);
				//Sort Gaussians by their ability to represent the background for later use
				float[][] sortedGaussians = sortGaussians(i);
				//If no match was found
				if(matchedGaussian ==-1){
					int leastWeighted = leastWeighted(i);
					mean[leastWeighted][i] = val;
					variance[leastWeighted][i] = initialVariance;
					imgOut[i] = (byte)Math.floor(mean[(int)sortedGaussians[0][0]][i]);
	//				imgOut[i] = 70;
				}
				else{
					//Calculate probability of belonging to this Gaussian distribution
					//	Calculate exponent
					probability[matchedGaussian] = hightestVariance*hightestVariance;
					probability[matchedGaussian] /= -2*(variance[matchedGaussian][i]*variance[matchedGaussian][i]);
					//	Calculate rest
					probability[matchedGaussian] = (float)Math.pow(Math.E, probability[matchedGaussian]);
					probability[matchedGaussian] /= variance[matchedGaussian][i]*SQRT2PI;
					
					for(int k = 0; k < amountGaussian; k++){
						weights[k][i] = (1-learningRate)* weights[k][i];
					}
					//Update mean and variance values
					weights[matchedGaussian][i] += learningRate;
					probability[matchedGaussian]*= learningRate;
					mean[matchedGaussian][i] = mean[matchedGaussian][i] * (1-probability[matchedGaussian]) + (probability[matchedGaussian] * val);
					variance[matchedGaussian][i] = (float)Math.sqrt(variance[matchedGaussian][i] * (1-probability[matchedGaussian]) + (probability[matchedGaussian] *hightestVariance*hightestVariance));
					
					//See if matched gaussian belongs to back or foreground
					boolean isBackground =false;
					float addedWeights =0;
					for(int k =0; k < amountGaussian; k++){
						int index = (int)sortedGaussians[0][k];
						addedWeights+=sortedGaussians[1][k];
						if(addedWeights>backgroundPercentage) break;
						if(matchedGaussian == index){
							isBackground = true;
							break;
						}
					}
					
					if(isBackground) imgOut[i] = imgIn[i];
					else imgOut[i] = (byte)Math.floor(mean[(int)sortedGaussians[0][0]][i]);
	//				else imgOut[i] = -1;
				}
			}
		}
		return imgOut;
	}
	
	/**
	 * returns a 2D Array with the indexes on first Array and weights on 2nd
	 * @param i
	 * @return
	 */
	private float[][] sortGaussians(int i){
		//Insertion sort is used
		float[][] result = new float[2][amountGaussian];
		float[] weights = new float[amountGaussian];
		for(int k = 0; k < amountGaussian; k++){
			weights[k] = this.weights[k][i]/variance[k][i];
		}
		for(int k =0; k < amountGaussian; k++){
			result[1][k] = -1;
		}
		for(int l = 0; l< amountGaussian; l++){
			float maxWeight = 0;
			int maxIndex =0 ;
			for(int k = 0; k < amountGaussian; k++){
				if(weights[k] > maxWeight) {
					maxWeight = weights[k];
					maxIndex = k;
				}
			}
			result[1][l] = this.weights[maxIndex][i];
			result[0][l] = maxIndex;
			weights[maxIndex] =0;
		}
		return result;
	}
	
	private void normalizeWeights(int i){
		float weightsAdded =0;
		for(int k=0; k < amountGaussian; k++){
			weightsAdded+=this.weights[k][i];
		}
		for(int k =0; k<amountGaussian; k++){
			this.weights[k][i] /= weightsAdded;
		}
	}
	
	private int leastWeighted(int i){
		int leastWeighted =0;
		for(int k = 0; k < amountGaussian; k++){
			if(weights[leastWeighted][i]> weights[k][i])
				leastWeighted = k;
		}
		return leastWeighted;
	}
	
}