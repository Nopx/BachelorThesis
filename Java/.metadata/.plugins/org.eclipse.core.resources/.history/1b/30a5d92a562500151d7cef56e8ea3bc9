package JolleeB.BachelorT.Algorithmen;

import JolleeB.BachelorT.Utils.Conversion;

public class MRFOptimizer {

	public float[] optimizeRandomField(byte[] img, float[] field, int width, int height){
		if(field.length != width*height) throw new IllegalArgumentException();
		int changeCounter =1;
		while(changeCounter >0){
			changeCounter =0;
			float[] newField = new float[field.length];
			for(int y =0; y < height; y++){
				for(int x =0; x < width; x++){
					int pos = y*width+x;
					float distanceSum =0;
					int totalSum =0;
					float totalProbabilities =0;
					for(int lFactor =-3; lFactor<=3; lFactor+=3){
						for(int kFactor =-3; kFactor<=3;kFactor+=3){
							int l = lFactor*3;
							int k = kFactor*3;
							int newY = y+l;
							int newX = x+k;
							if(newY <0 || newY >=height)newY-=l;
							if(newX <0 || newX >=width )newX-=k;
							int newPos = newY*width+newX;
							if(newPos != pos){
								int diff = (Conversion.byteToInt(img[pos])-Conversion.byteToInt(img[newPos]));
								diff *= diff;
								distanceSum -= diff*field[newPos];
								totalSum += diff;
								totalProbabilities += field[newPos];
							}
						}
					}
					if(totalSum ==0) newField[pos] = totalProbabilities/
					distanceSum /= totalSum;
					newField[pos] = totalProbabilities +distanceSum;
				}
			}
		}
		return null;
	}
}
