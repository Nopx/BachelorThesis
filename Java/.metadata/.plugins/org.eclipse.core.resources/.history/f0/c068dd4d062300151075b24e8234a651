package JolleeB.BachelorT.Algorithmen;

import java.util.Random;

import JolleeB.BachelorT.Utils.Conversion;
import JolleeB.BachelorT.Utils.ImageFormatingUtils;
import JolleeB.BachelorT.Utils.ImageUtils;

public class SpatialGMMAnalyzer {
	private int imgLength;
	private int imgWidth;
	private int imgHeight;
	private float learningRate = 0.01f;
	private float[] mean;
	private float[] variance;
	
	public SpatialGMMAnalyzer(int imgWidth, int imgHeight){
		this.imgLength = imgWidth*imgHeight;
		this.imgHeight = imgHeight;
		this.imgWidth = imgWidth;
		this.mean = new float[imgLength];
		this.variance = new float[imgLength];
		for(int i =0; i <this.imgLength; i++){
			this.mean[i] = 128;
			this.variance[i] = 3;
		}
	}
	
	public byte[] convertImage(byte[] imgIn){
		if(imgIn.length != imgLength) throw new IllegalArgumentException();
		byte[] imgInClone = ImageFormatingUtils.makeGrayScaleImage(imgIn);
		int length = this.imgLength/3;
		byte[] imgOut = new byte[length];
		for(int i = 0; i <length; i++){
			int x = Conversion.byteToInt(imgInClone[i]);
			float meanMix = (mean[3*i]+mean[3*i+1]+mean[3*i+2])/3;
			boolean isForeground = Math.abs(x-mean[i])>variance[i];
			
			//Update Pixel in new Picture
			if(isForeground) imgOut[i] = 0;	
			else imgOut[i] = -1;
		}
		imgOut = ImageUtils.medianFilterGrayScale(imgOut, this.imgWidth/3, this.imgHeight, 5);
		imgOut = ImageFormatingUtils.makeColorScale(imgOut);
		for(int i =0; i < imgLength; i++){
			int x = Conversion.byteToInt(imgIn[i]);
			
			//Update mean and variance values
			mean[i] = mean[i] * (1-learningRate) + (learningRate * x);
			variance[i] = (float)Math.sqrt(variance[i] * (1-learningRate) + (learningRate *(x-mean[i])*(x-mean[i])));
			
			if(imgOut[i] ==0) imgOut[i]=(byte)mean[i];
			else imgOut[i] = imgIn[i];
		}
		return imgOut;
	}
	
}